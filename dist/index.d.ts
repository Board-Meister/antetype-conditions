// Generated by dts-bundle-generator v9.5.1

import { IIllustrator } from '@boardmeister/antetype-illustrator';
import { IExportSettings, IWorkspace } from '@boardmeister/antetype-workspace';
import Marshal from '@boardmeister/marshal';
import { Module } from '@boardmeister/marshal';

declare type UnknownRecord = Record<symbol | string, unknown>;
declare type Module$1 = object;
interface Modules {
	core?: ICore;
	[key: string]: Module$1 | undefined;
}
type ITypeDefinitionPrimitive = "boolean" | "string" | "number";
type TypeDefinition = {
	[key: string]: ITypeDefinitionPrimitive | TypeDefinition | TypeDefinition[];
} | (ITypeDefinitionPrimitive)[] | TypeDefinition[];
type ITypeDefinitionMap = Record<string, TypeDefinition>;
type Canvas = HTMLCanvasElement | OffscreenCanvas;
interface CalcEvent {
	element: IBaseDef;
	sessionId: symbol | null;
}
interface ISettingFont {
	name: string;
	url: string;
}
interface ISettings {
	[key: string | number | symbol]: unknown;
	core?: {
		fonts?: ISettingFont[];
	};
}
interface ISettingsDefinitionFieldGeneric {
	label: string;
	type: string;
}
type SettingsDefinitionField = ISettingsDefinitionFieldInput | ISettingsDefinitionFieldContainer | ISettingsDefinitionFieldGeneric;
interface ISettingsDefinitionFieldContainer extends ISettingsDefinitionFieldGeneric {
	type: "container";
	fields: SettingsDefinitionField[][];
	collapsable?: boolean;
}
type ISettingsInputValue = string | number | (string | number | Record<string, any>)[] | Record<string, any> | undefined;
interface ISettingsDefinitionFieldInput extends ISettingsDefinitionFieldGeneric {
	name: string;
	value: ISettingsInputValue;
}
interface ISettingsDefinitionTab {
	label: string;
	icon?: string;
	fields: SettingsDefinitionField[][];
}
interface ISettingsDefinition {
	details: {
		label: string;
		icon?: string;
	};
	name: string;
	tabs: ISettingsDefinitionTab[];
}
declare type XValue = number;
declare type YValue = XValue;
interface IStart {
	x: XValue;
	y: YValue;
}
interface ISize {
	w: XValue;
	h: YValue;
}
interface IArea {
	size: ISize;
	start: IStart;
}
interface IHierarchy {
	parent: IParentDef | null;
	position: number;
}
interface IBaseDef<T = never> {
	[key: symbol | string]: unknown;
	id?: string;
	hierarchy?: IHierarchy;
	start: IStart;
	size: ISize;
	type: string;
	can?: {
		move?: boolean;
		scale?: boolean;
		remove?: boolean;
	};
	area?: IArea;
	data?: T;
}
interface IParentDef extends IBaseDef {
	layout: Layout;
}
interface IDocumentDef extends IParentDef {
	type: "document";
	base: Layout;
	start: {
		x: 0;
		y: 0;
	};
	size: {
		w: 0;
		h: 0;
	};
	settings: ISettings;
}
interface IFont {
	url: string;
	name: string;
}
interface ICore extends Module$1 {
	meta: {
		document: IDocumentDef;
		generateId: () => string;
		layerDefinitions: () => ITypeDefinitionMap;
		getCanvas: () => Canvas | null;
		setCanvas: (newCanvas: null | Canvas) => Promise<void>;
	};
	clone: {
		definitions: (data: IBaseDef) => Promise<IBaseDef>;
		getOriginal: <T extends UnknownRecord = UnknownRecord>(object: T) => T;
		getClone: <T extends UnknownRecord = UnknownRecord>(object: T) => T;
	};
	manage: {
		markAsLayer: (layer: IBaseDef) => IBaseDef;
		add: (def: IBaseDef, parent?: IParentDef | null, position?: number | null) => void;
		addVolatile: (def: IBaseDef, parent?: IParentDef | null, position?: number | null) => void;
		remove: (def: IBaseDef) => void;
		removeVolatile: (def: IBaseDef) => void;
		calcAndUpdateLayer: (original: IBaseDef) => Promise<void>;
	};
	view: {
		calc: (element: IBaseDef, parent?: IParentDef, position?: number, currentSession?: symbol | null) => Promise<IBaseDef>;
		draw: (element: IBaseDef) => void;
		redraw: (layout?: Layout) => void;
		recalculate: (parent?: IParentDef, layout?: Layout, currentSession?: symbol | null) => Promise<Layout>;
		redrawDebounce: (layout?: Layout) => void;
		recalculateDebounce: (parent?: IParentDef, layout?: Layout, currentSession?: symbol | null) => Promise<Layout>;
		move: (original: IBaseDef, newStart: IStart) => Promise<void>;
		resize: (original: IBaseDef, newSize: ISize) => Promise<void>;
	};
	policies: {
		isLayer: (layer: Record<symbol, unknown>) => boolean;
		isClone: (layer: Record<symbol, unknown>) => boolean;
	};
	font: {
		load: (font: IFont) => Promise<FontFaceSet | null>;
		reload: () => Promise<(FontFaceSet | null)[]>;
	};
	setting: {
		set: (name: string, value: unknown) => void;
		// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters
		get: <T = unknown>(name: string) => T | null;
		has: (name: string) => boolean;
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		retrieve: (additional?: Record<string, any>) => Promise<ISettingsDefinition[]>;
	};
}
type Layout = (IBaseDef | IParentDef)[];
type AmbiguousSubscription = string | OptionalSubscription | OptionalSubscription[] | EventHandler;
type EventHandler = (event: CustomEvent) => Promise<any> | any;
type Anchor = Node | object | symbol | null;
interface OptionalSubscription {
	method: string | EventHandler;
	priority?: number;
	constraint?: string | Module | null;
	anchor?: Anchor;
}
interface IEventRegistration {
	event: string;
	subscription: AmbiguousSubscription;
	constraint?: string | Module | null;
	sort?: boolean;
	symbol?: symbol | null;
	anchor?: Anchor;
}
interface IListen {
	event: string;
	subscription: AmbiguousSubscription;
	anchor?: Anchor;
	symbol?: symbol | null;
	sort?: boolean;
	constraint?: string | Module | null;
}
type LocalizedEventDirection = "up" | "down" | "both";
interface IEventSettings {
	origin?: Anchor;
	direction?: LocalizedEventDirection;
}
declare class Herald {
	#private;
	constructor(marshal?: Marshal | null);
	dispatch(event: CustomEvent, settings?: IEventSettings): Promise<void>;
	dispatchSync(event: CustomEvent, settings?: IEventSettings): void;
	batch(events: IEventRegistration[]): () => void;
	/**
	 * Wrapper method for `register`
	 * Makes is easier when you want to specify just anchor or just symbol. Thanks to that we don't have to write:
	 *
	 * `register('event', [], null, null, null, Node);`
	 *
	 * instead we can:
	 *
	 * `listen({event: 'event', subscription: [], anchor: Node});`
	 *
	 * still, using registration can result in a smaller size, so it's not completely useless.
	 */
	listen({ event, subscription, constraint, sort, symbol, anchor, }: IListen): () => void;
	register(event: string, subscription: AmbiguousSubscription, constraint?: string | Module | null, sort?: boolean, symbol?: symbol | null, anchor?: Anchor): () => void;
	unregister(event: string, symbol: symbol): void;
}
interface Modules$1 extends Modules {
	core: ICore;
	illustrator: IIllustrator;
	workspace: IWorkspace;
	conditions: IConditions;
}
interface IParams {
	modules: Modules$1;
	herald: Herald;
}
declare function ConditionsModule({ herald, modules, }: IParams): IConditions;
interface ICrud {
	addInput: (layer: IConditionAwareDef, input: IInput) => IInputHandler;
	removeInput: (handler: IInputHandler) => void;
	getInputById: (id: string) => IInputHandler | null;
	getInputByType: (type: string) => IInput | null;
	getMethod: (type: string) => IMethod | null;
	getInputs: () => IInputHandler[];
	getInputLayer: (input: IInputHandler) => IConditionAwareDef | null;
	addEmptyAction: (layer: IConditionAwareDef) => IAction;
	removeAction: (actions: IAction[], action: IAction) => void;
	addChange: (action: IAction, method: IMethod) => IChange;
	removeChange: (action: IAction, change: IChange) => void;
	registerInput: (layer: IConditionAwareDef, handler: IInputHandler) => void;
	registerNewInputs: (layer: IConditionAwareDef) => void;
	registerNewActions: (layer: IConditionAwareDef) => void;
}
interface IEventReturn {
	retrieveInputs: () => Promise<Record<string, IInput>>;
	retrieveMethods: () => Promise<Record<string, IMethod>>;
}
interface IReturnProps {
	generateActionArguments: () => Record<string, unknown>;
	canActionResolve: (action: IAction, args?: Record<string, unknown> | null) => boolean;
	resolveArguments: (args: IMethodArgument[]) => unknown[];
}
interface IBulkReturn {
	bulkGenerate: (inputValuesRows: IBulkValues[]) => Promise<string | null>[];
}
interface IInputValues {
	[key: string]: string;
}
interface IBulkValues {
	settings?: IExportSettings;
	values: IInputValues;
}
export const inputLayerSymbol = Symbol("Input Layer");
export const actionLayerSymbol = Symbol("Action Layer");
export const changeActionSymbol = Symbol("Change Action");
declare enum Event$1 {
	REGISTER_INPUT = "antetype.conditions.input.register",
	REGISTER_METHOD = "antetype.conditions.method.register"
}
export interface IInputHandler<T = string | number | null | string[] | number[]> extends Record<string | symbol, unknown> {
	id?: string;
	[inputLayerSymbol]?: IConditionAwareDef;
	type: string;
	name: string;
	value: T;
}
export interface ITitleInputHandler extends IInputHandler<string | null> {
	placeholder?: string;
}
export interface ISelectOption {
	label: string;
	value: string;
	checked: boolean | null;
}
export interface IMultiselectOption {
	label: string;
	value: string;
	checked: boolean | null;
}
export interface ISelectInputHandler extends IInputHandler<string | null> {
	options: ISelectOption[];
}
export interface IMultiselectInputHandler extends IInputHandler<string[] | null> {
	options: IMultiselectOption[];
}
export type IImageInputHandler = IInputHandler<string | null>;
export interface IInput<G extends IInputHandler = IInputHandler> {
	type: string;
	name: string;
	generate: (layer: IBaseDef) => G;
	description?: string;
	icon?: string;
}
export interface IConditionInstruction {
	text: string;
}
export interface IChange {
	[changeActionSymbol]?: IAction;
	type: string;
	arguments: IMethodArgument[];
}
export interface IAction {
	[actionLayerSymbol]?: IConditionAwareDef;
	rule: IConditionInstruction;
	changes: IChange[];
	name?: string;
}
export interface IConditionParams {
	inputs?: IInputHandler[];
	actions?: IAction[];
}
export interface IConditionAwareDef extends IBaseDef {
	conditions?: IConditionParams;
}
export interface IMethodArgument extends Record<string, any> {
	type: string;
	name: string;
	value?: any;
	inputId?: string;
}
export interface IResolveArgument {
	event: CustomEvent<CalcEvent>;
	layer: IConditionAwareDef;
}
export interface IMethod<T extends any[] = any[], P = unknown> {
	name: string;
	type: string;
	arguments?: IMethodArgument[];
	resolve: (argument: IResolveArgument, ...args: T) => P;
}
export type SetImageMethod = IMethod<(string | null)[]>;
export type SetTextMethod = IMethod<(string | null)[]>;
export type SetPropertyMethod = IMethod<(string | null)[]>;
export interface IRegisterInputEvent {
	inputs: Record<string, IInput>;
}
export type RegisterInputEvent = CustomEvent<IRegisterInputEvent>;
export interface IRegisterMethodEvent {
	methods: Record<string, IMethod>;
}
export type RegisterMethodEvent = CustomEvent<IRegisterMethodEvent>;
export interface IConditions extends ICrud, IEventReturn, IReturnProps, IBulkReturn {
	getInputsMap: () => Record<string, IInput>;
	getMethodsMap: () => Record<string, IMethod>;
}
export declare const ID = "conditions";
export declare const VERSION = "0.0.4";

export {
	ConditionsModule as Conditions,
	Event$1 as Event,
};

export {};
