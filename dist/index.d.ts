// Generated by dts-bundle-generator v9.5.1

import { CalcEvent, IBaseDef, ICore, Modules } from '@boardmeister/antetype-core';
import { Herald } from '@boardmeister/herald';

interface ModulesWithCore extends Modules {
	core: ICore;
}
interface IParams {
	canvas: HTMLCanvasElement | null;
	modules: ModulesWithCore;
	herald: Herald;
}
declare function ConditionsModule({ herald, modules, }: IParams): IConditions;
interface ICrud {
	addInput: (layer: IConditionAwareDef, input: IInput) => IInputHandler;
	removeInput: (handler: IInputHandler) => void;
	getInputById: (id: string) => IInputHandler | null;
	getInputByType: (type: string) => IInput | null;
	getMethod: (type: string) => IMethod | null;
	getInputs: () => IInputHandler[];
	getInputLayer: (input: IInputHandler) => IConditionAwareDef | null;
	addEmptyAction: (layer: IConditionAwareDef) => IAction;
	removeAction: (actions: IAction[], action: IAction) => void;
	addChange: (action: IAction, method: IMethod) => IChange;
	removeChange: (action: IAction, change: IChange) => void;
	registerInput: (layer: IConditionAwareDef, handler: IInputHandler) => void;
	registerNewInputs: (layer: IConditionAwareDef) => void;
	registerNewActions: (layer: IConditionAwareDef) => void;
}
interface IEventReturn {
	retrieveInputs: () => Promise<Record<string, IInput>>;
	retrieveMethods: () => Promise<Record<string, IMethod>>;
}
interface IReturnProps {
	generateActionArguments: () => Record<string, unknown>;
	canActionResolve: (action: IAction, args?: Record<string, unknown> | null) => boolean;
	resolveArguments: (args: IMethodArgument[]) => unknown[];
}
export const inputLayerSymbol = Symbol("Input Layer");
export const actionLayerSymbol = Symbol("Action Layer");
export const changeActionSymbol = Symbol("Change Action");
declare enum Event$1 {
	REGISTER_INPUT = "antetype.conditions.input.register",
	REGISTER_METHOD = "antetype.conditions.method.register"
}
export interface IInputHandler<T = string | number | null | string[] | number[]> extends Record<string | symbol, unknown> {
	id?: string;
	[inputLayerSymbol]?: IConditionAwareDef;
	type: string;
	name: string;
	value: T;
}
export interface ITitleInputHandler extends IInputHandler<string | null> {
	placeholder?: string;
}
export interface ISelectOption {
	label: string;
	value: string;
	checked: boolean | null;
}
export interface IMultiselectOption {
	label: string;
	value: string;
	checked: boolean | null;
}
export interface ISelectInputHandler extends IInputHandler<string | null> {
	options: ISelectOption[];
}
export interface IMultiselectInputHandler extends IInputHandler<string[] | null> {
	options: IMultiselectOption[];
}
export type IImageInputHandler = IInputHandler<string | null>;
export interface IInput<G extends IInputHandler = IInputHandler> {
	type: string;
	name: string;
	generate: (layer: IBaseDef) => G;
	description?: string;
	icon?: string;
}
export interface IConditionInstruction {
	text: string;
}
export interface IChange {
	[changeActionSymbol]?: IAction;
	type: string;
	arguments: IMethodArgument[];
}
export interface IAction {
	[actionLayerSymbol]?: IConditionAwareDef;
	rule: IConditionInstruction;
	changes: IChange[];
	name?: string;
}
export interface IConditionParams {
	inputs?: IInputHandler[];
	actions?: IAction[];
}
export interface IConditionAwareDef extends IBaseDef {
	conditions?: IConditionParams;
}
export interface IMethodArgument extends Record<string, any> {
	type: string;
	name: string;
	value?: any;
	inputId?: string;
}
export interface IResolveArgument {
	event: CustomEvent<CalcEvent>;
	layer: IConditionAwareDef;
}
export interface IMethod<T extends any[] = any[], P = unknown> {
	name: string;
	type: string;
	arguments?: IMethodArgument[];
	resolve: (argument: IResolveArgument, ...args: T) => P;
}
export type SetImageMethod = IMethod<(string | null)[]>;
export type SetTextMethod = IMethod<(string | null)[]>;
export type SetPropertyMethod = IMethod<(string | null)[]>;
export interface IRegisterInputEvent {
	inputs: Record<string, IInput>;
}
export type RegisterInputEvent = CustomEvent<IRegisterInputEvent>;
export interface IRegisterMethodEvent {
	methods: Record<string, IMethod>;
}
export type RegisterMethodEvent = CustomEvent<IRegisterMethodEvent>;
export interface IConditions extends ICrud, IEventReturn, IReturnProps {
	getInputsMap: () => Record<string, IInput>;
	getMethodsMap: () => Record<string, IMethod>;
}

export {
	ConditionsModule as Conditions,
	Event$1 as Event,
};

export {};
